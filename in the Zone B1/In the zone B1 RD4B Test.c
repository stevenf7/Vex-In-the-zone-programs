#pragma config(Sensor, in1,    MobilePotL,     sensorPotentiometer)
#pragma config(Sensor, in2,    MobilePotR,     sensorPotentiometer)
#pragma config(Sensor, in3,    ArmPotL,        sensorPotentiometer)
#pragma config(Sensor, in4,    ArmPotR,        sensorPotentiometer)
#pragma config(Sensor, in5,    ClawArmPotL,    sensorPotentiometer)
#pragma config(Sensor, in6,    ClawArmPotR,    sensorPotentiometer)
#pragma config(Sensor, in7,    Auton,          sensorPotentiometer)
#pragma config(Sensor, dgtl9,  EncRight,       sensorQuadEncoder)
#pragma config(Sensor, dgtl11, EncLeft,        sensorQuadEncoder)
#pragma config(Motor,  port1,           MobileGoalL,   tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           Left1,         tmotorVex393_MC29, openLoop, driveLeft, encoderPort, dgtl11)
#pragma config(Motor,  port3,           BR,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           ClawArmL,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           TR,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           TL,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           ClawArmR,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           BL,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           Right1,        tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, dgtl9)
#pragma config(Motor,  port10,          MobileGoalR,   tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int LoptimalL;
int LoptimalR;



task PID_RD4B()
{
	float lkp = 0.16; //tune
	float lki = 0.00000001; //tune
	float lkd = 0.00000008; //tune

	float lcurrentL ;
	float lerrorTl;
	float llastErrorL = 0;
	float lproportionL;
	float lintegralL;
	float lderivativeL;
	float lcurrentR ;
	float lerrorTr;
	float llastErrorR = 0;
	float lproportionR;
	float lintegralR;
	float lderivativeR;

	while(true){


		float lerrorL = LoptimalL - SensorValue[ArmPotL];
		float lerrorR = LoptimalR - SensorValue[ArmPotR];



		if (abs(lerrorL) < 200 && lerrorL !=0)
		{
			lerrorTl = lerrorL;
		}
		else{
			lerrorTl = 0;
		}

		if (abs(lerrorR) < 200 &&lerrorR !=0)
		{
			lerrorTr = lerrorR;
		}
		else{
			lerrorTr = 0;
		}

		if (abs(lerrorTl)> 50 / lki){
			lerrorTl = 50 / lki;
		}

		if (lerrorL ==0){
			lderivativeL = 0;
		}

		if (abs(lerrorTr)> 50 / lki){
			lerrorTr = 50 / lki;
		}

		if (lerrorR ==0){
			lderivativeR = 0;
		}




		lproportionL = lerrorL * lkp;
		lproportionR = lerrorR * lkp;
		lintegralL = lerrorTl  * lki;
		lintegralR = lerrorTr  * lki;
		lderivativeL = (lerrorL - llastErrorL) * lkd;
		lderivativeR = (lerrorR - llastErrorR) * lkd;

		llastErrorL = lerrorL;
		llastErrorR = lerrorR;

		lcurrentL = lproportionL + lintegralL + lderivativeL;
		lcurrentR = lproportionR + lintegralR + lderivativeR;

		 motor[TR]= motor [BR] = -lcurrentR;
		motor[TL] = motor [BL] = -lcurrentL;



		wait1Msec(40);

	}
	return;

}


task main()
{


	LoptimalL = SensorValue [ArmPotL];
	LoptimalR = SensorValue [ArmPotR];

	startTask (PID_RD4B);





	while (true){


		if(vexRT[Btn5U] == 1)
		{
			while((vexRT[Btn5U] ==1)&&(SensorValue[ArmPotL]<2225)) {
				motor [TL] = motor [TR] = motor[BL] = motor[BR]  = 120;

				wait1Msec (40);

			}
		}
		else if(vexRT[Btn5D] == 1)
		{
			while(vexRT[Btn5D] ==1) {
				motor [TL] = motor [TR] = motor[BL] = motor[BR] =  -120;

				wait1Msec (40);

			}
		}

		else {
			motor [TL] = motor [TR] = motor[BL] = motor[BR] = 0;
		}



		wait1Msec(40);
	}
}
