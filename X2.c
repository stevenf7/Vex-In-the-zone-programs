#pragma config(Sensor, in1,    Gyro,           sensorGyro)
#pragma config(Sensor, in2,    MogoPot,        sensorPotentiometer)
#pragma config(Sensor, in3,    ArmPotL,        sensorPotentiometer)
#pragma config(Sensor, in4,    ArmPotR,        sensorPotentiometer)
#pragma config(Sensor, in5,    ClawArmPotL,    sensorPotentiometer)
#pragma config(Sensor, in6,    ClawArmPotR,    sensorPotentiometer)
#pragma config(Sensor, in7,    Auton,          sensorPotentiometer)
#pragma config(Sensor, dgtl7,  EncRoll,        sensorNone)
#pragma config(Sensor, dgtl9,  EncRight,       sensorQuadEncoder)
#pragma config(Sensor, dgtl11, EncLeft,        sensorQuadEncoder)
#pragma config(Motor,  port1,           Right2,        tmotorVex393_HBridge, openLoop, reversed, driveRight, encoderPort, dgtl9)
#pragma config(Motor,  port2,           Left1,         tmotorVex393_MC29, openLoop, driveLeft, encoderPort, dgtl11)
#pragma config(Motor,  port3,           Roller,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           ClawArmL,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           TL,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           TR,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           ClawArmR,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           Mogo,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           Right1,        tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, dgtl9)
#pragma config(Motor,  port10,          Left2,         tmotorVex393_HBridge, openLoop, driveLeft, encoderPort, dgtl11)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//+310 rotations for a 90 degree turn

//int MoptimalL;
//int MoptimalR;
//int CoptimalL;
//int CoptimalR;
int AoptimalL;
int AoptimalR;
int CoptimalL;
int CoptimalR;
int MoptimalL;
int MoptimalR;

task PID_ArmsLift()
{
	float akp = 0.16; //tune
	float aki = 0.00000001; //tune
	float akd = 0.00000008; //tune

	float acurrentL;
	float aerrorTL;
	float alastErrorL = 0;
	float aproportionL;
	float aintegralL;
	float aderivativeL;
	float acurrentR ;
	float aerrorTR;
	float alastErrorR = 0;
	float aproportionR;
	float aintegralR;
	float aderivativeR;

	while(true){


		float aerrorL = AoptimalL - SensorValue[ArmPotL];
		float aerrorR = AoptimalR - SensorValue[ArmPotR];

		if (abs(aerrorL) < 200 && aerrorL != 0)
		{
			aerrorTL = aerrorL;
		}
		else{
			aerrorTL = 0;
		}

		if (abs(aerrorR) < 200 && aerrorR != 0)
		{
			aerrorTR = aerrorR;
		}

		else{
			aerrorTR = 0;
		}

		if (abs(aerrorTL) > 50 / aki){
			aerrorTL = 50 / aki;
		}

		if (aerrorL == 0){
			aderivativeL = 0;
		}

		if (abs(aerrorTR) > 50 / aki){
			aerrorTR = 50 / aki;
		}

		if (aerrorR == 0){
			aderivativeR = 0;
		}

		aproportionL = aerrorL * akp;
		aproportionR = aerrorR * akp;
		aintegralL = aerrorTl  * aki;
		aintegralR = aerrorTr  * aki;
		aderivativeL = (aerrorL - alastErrorL) * akd;
		aderivativeR = (aerrorR - alastErrorR) * akd;

		alastErrorL = aerrorL;
		alastErrorR = aerrorR;

		acurrentL = aproportionL + aintegralL + aderivativeL;
		acurrentR = aproportionR + aintegralR + aderivativeR;

		motor[TL] = -acurrentL;
		motor[TR] = -acurrentR;

		wait1Msec(40);

	}
	return;

}

task PID_ClawLift()
{
    float ckp = 0.16; //tune
    float cki = 0.00000001; //tune
    float ckd = 0.00000008; //tune

    float ccurrentL ;
    float cerrorTl;
    float clastErrorL = 0;
    float cproportionL;
    float cintegralL;
    float cderivativeL;
    float ccurrentR ;
    float cerrorTr;
    float clastErrorR = 0;
    float cproportionR;
    float cintegralR;
    float cderivativeR;

    while(true){


        float cerrorL = CoptimalL - SensorValue[ClawArmPotL];
        float cerrorR = CoptimalR - SensorValue[ClawArmPotR];

        if (abs(cerrorL) < 200 && cerrorL !=0)
        {
            cerrorTl = cerrorL;
        }
        else{
            cerrorTl = 0;
        }

        if (abs(cerrorR) < 200 &&cerrorR !=0)
        {
            cerrorTr = cerrorR;
        }
        else{
            cerrorTr = 0;
        }

        if (abs(cerrorTl)> 50 / cki){
            cerrorTl = 50 / cki;
        }

        if (cerrorL ==0){
            cderivativeL = 0;
        }

        if (abs(cerrorTr)> 50 / cki){
            cerrorTr = 50 / cki;
        }

        if (cerrorR ==0){
            cderivativeR = 0;
        }




        cproportionL = cerrorL * ckp;
        cproportionR = cerrorR * ckp;
        cintegralL = cerrorTl  * cki;
        cintegralR = cerrorTr  * cki;
        cderivativeL = (cerrorL - clastErrorL) * ckd;
        cderivativeR = (cerrorR - clastErrorR) * ckd;

        clastErrorL = cerrorL;
        clastErrorR = cerrorR;

        ccurrentL = cproportionL + cintegralL + cderivativeL;
        ccurrentR = cproportionR + cintegralR + cderivativeR;

        motor[ClawArmR] = -ccurrentR;
        motor[ClawArmL] = -ccurrentL;



        wait1Msec(40);

    }
    return;

}

task PID_MG()
{
    float mkp = 0.3; //tune
    float mki = 0.001; //tune
    float mkd = 0.2; //tune

    float mcurrentL ;
    float merrorTl;
    float mproportionL;
    float mintegralL;
    float mderivativeL;
    float mcurrentR ;
    float merrorTr;
    float mlastErrorR = 0;
    float mproportionR;
    float mintegralR;
    float mderivativeR;

    while(true){

        float merrorR = (MoptimalR - SensorValue[MogoPot]);

        if (abs(merrorR) < 200 && merrorR !=0)
        {
            merrorTr = merrorR;
        }
        else{
            merrorTr = 0;
        }

        if (abs(merrorTl)> 50 / mki){
            merrorTl = 50 / mki;
        }

        if (abs(merrorTr)> 50 / mki){
            merrorTr = 50 / mki;
        }

        if (merrorR ==0){
            mderivativeR = 0;
        }

        mproportionR = merrorR * mkp;
        mintegralL = merrorTl  * mki;
        mintegralR = merrorTr  * mki;
        mderivativeR = (merrorR - mlastErrorR) * mkd;

        mlastErrorR = merrorR;

        mcurrentL = mproportionL + mintegralL + mderivativeL;
        mcurrentR = mproportionR + mintegralR + mderivativeR;

        motor[Mogo] = mcurrentR;



        wait1Msec(40);

    }
    return;
}

task main()
{
    MoptimalR = SensorValue [MogoPot];
    CoptimalL = SensorValue [ClawArmPotL];
    CoptimalR = SensorValue [ClawArmPotR];
    AoptimalL = SensorValue [ArmPotL];
    AoptimalR = SensorValue [ArmPotR];

    //    startTask (PID_MG);
    //    startTask (PID_ClawLift);
    //    startTask (PID_ArmsLift);

    while (true){

        if(vexRT[Btn5UXmtr2] == 1)
        {
            while((vexRT[Btn7DXmtr2] == 1)) {
                motor[Roller] = 120;

                wait1Msec (40);
            }
        }
        else if(vexRT[Btn8DXmtr2] == 1)
        {
            while(vexRT[Btn8DXmtr2] == 1) {
                motor[Roller] = -120;

                wait1Msec (40);
            }
        }

        else {
            motor[Roller] = 30;
        }
/*
        if(vexRT[Btn5UXmtr2] == 1)
        {
            while( (vexRT[Btn5UXmtr2] == 1) && ((SensorValue[ArmPotL] < 2225) || (SensorValue[ArmPotR] < 2225)) {
                motor[TL] = 120;
                motor[TR] = 120;

                wait1Msec (40);
            }
        }
        else if((vexRT[Btn5DXmtr2] == 1) && ((SensorValue[ArmPotL] < -2225) || (SensorValue[ArmPotR] < -2225)))
        {
            while(vexRT[Btn5DXmtr2] == 1) {
                motor[TL] = -120;
                motor[TR] = -120;

                wait1Msec (40);
            }
        }

        else{
        motor[TL] = 0;
        motor[TR] = 0;
        }
*/
        if ((vexRT[Btn5UXmtr2] ==1 ) && (SensorValue[ArmPotL] < 2225)){
           AoptimalL = SensorValue[ArmPotL] - 100;
           AoptimalR = SensorValue[ArmPotR] - 100;
        }
        else if (vexRT[Btn5DXmtr2] ==1 ){
           AoptimalL = SensorValue[ArmPotL] + 100;
           AoptimalR = SensorValue[ArmPotR] + 100;
        }
        else{

        }


        if ((vexRT [Btn6UXmtr2] == 1)||(vexRT [Btn6UXmtr2] == 1)) {
           // motor[ClawArmL] = motor[ClawArmR] = 120;
            CoptimalL = 939;
            CoptimalR = 800;
        }

        else if ((vexRT[Btn6DXmtr2] == 1)||(vexRT[Btn6DXmtr2] == 1)){
                CoptimalL = 2550;
                CoptimalR = 2700;
          //  motor[ClawArmL] = motor[ClawArmR] = -120;
        }
        else {
           // motor[ClawArmL] = motor[ClawArmR] = 0;
        }

        if ((vexRT [Btn8D] == 1)/*||(vexRT [Btn5DXmtr2] == 1)*/) {
            MoptimalL = 1410;
            MoptimalR = 1382;
        }

        else if ((vexRT [Btn8U] == 1)||(vexRT [Btn5UXmtr2] == 1)) {
            MoptimalL = 4090;
            MoptimalR = 4020;
        }
        else {
            MoptimalR = SensorValue[MogoPot];
        }

        //---------------------------------------------------------------------------------------------------------------

        float ch3_drive;
        float ch1_drive;
        float a = vexRT[Ch3] / 127.0;
        float b = vexRT[Ch1] / 127.0;
        ch3_drive = (0.463 * (pow(a,3))- (0.069 * pow(a,2)) + (0.614 * a) ) * 127;
        ch1_drive = (0.463 * (pow(b,3))- (0.069 * pow(b,2)) + (0.614 * b) ) * 127;


        motor[Left1]  = ((ch3_drive) + (ch1_drive));
        motor[Left2]  = ((ch3_drive) + (ch1_drive));
        motor[Right1] = ((ch3_drive) - (ch1_drive));
        motor[Right2] = ((ch3_drive) - (ch1_drive));

        wait1Msec(40);

        float TR_lift;
        float TL_lift;
        float TRlift = vexRT[Btn5U] / 127.0;
        float TLlift = vexRT[Btn5U] / 127.0;
        TR_lift = (0.463 * (pow(TRlift,3))- (0.069 * pow(TRlift,2)) + (0.614 * TRlift)) * 127;
        TL_lift= (0.463 * (pow(TLlift,3))- (0.069 * pow(TLlift,2)) + (0.614 * TLlift)) * 127;

        motor[TR] = ((TR_lift) + TRlift);
        motor[TL] = ((TL_lift) + TLlift);
    }
}
