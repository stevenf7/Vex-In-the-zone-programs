#pragma config(Sensor, in2,    MobilePotR,     sensorPotentiometer)
#pragma config(Sensor, in3,    ArmPotL,        sensorPotentiometer)
#pragma config(Sensor, in4,    ArmPotR,        sensorPotentiometer)
#pragma config(Sensor, in5,    ClawArmPotL,    sensorPotentiometer)
#pragma config(Sensor, in6,    ClawArmPotR,    sensorPotentiometer)
#pragma config(Sensor, dgtl9,  EncRight,       sensorQuadEncoder)
#pragma config(Sensor, dgtl11, EncLeft,        sensorQuadEncoder)
#pragma config(Motor,  port1,           Right2,        tmotorVex393_HBridge, openLoop, reversed, driveRight, encoderPort, dgtl9)
#pragma config(Motor,  port2,           Left1,         tmotorVex393_MC29, openLoop, driveLeft, encoderPort, dgtl11)
#pragma config(Motor,  port3,           Roller,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           ClawArmL,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           TR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           TL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           ClawArmR,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           MobileGoalR,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           Right1,        tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, dgtl9)
#pragma config(Motor,  port10,          Left2,         tmotorVex393_HBridge, openLoop, driveLeft, encoderPort, dgtl11)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//int MoptimalL;
//int MoptimalR;
//int CoptimalL;
//int CoptimalR;
int AoptimalL;
int AoptimalR;

task PID_ArmsLift()
{
	float akp = 0.16; //tune
	float aki = 0.00000001; //tune
	float akd = 0.00000008; //tune

	float acurrentL;
	float aerrorTl;
	float alastErrorL = 0;
	float aproportionL;
	float aintegralL;
	float aderivativeL;
	float acurrentR ;
	float aerrorTr;
	float alastErrorR = 0;
	float aproportionR;
	float aintegralR;
	float aderivativeR;

	while(true){


		float aerrorL = AoptimalL - SensorValue[ArmPotL];
		float aerrorR = AoptimalR - SensorValue[ArmPotR];

		if (abs(aerrorL) < 200 && aerrorL !=0)
		{
			aerrorTl = aerrorL;
		}
		else{
			aerrorTl = 0;
		}

		if (abs(aerrorR) < 200 && aerrorR !=0)
		{
			aerrorTr = aerrorR;
		}
		else{
			aerrorTr = 0;
		}

		if (abs(aerrorTl)> 50 / aki){
			aerrorTl = 50 / aki;
		}

		if (aerrorL ==0){
			aderivativeL = 0;
		}

		if (abs(aerrorTr)> 50 / aki){
			aerrorTr = 50 / aki;
		}

		if (aerrorR ==0){
			aderivativeR = 0;
		}

		aproportionL = aerrorL * akp;
		aproportionR = aerrorR * akp;
		aintegralL = aerrorTl  * aki;
		aintegralR = aerrorTr  * aki;
		aderivativeL = (aerrorL - alastErrorL) * akd;
		aderivativeR = (aerrorR - alastErrorR) * akd;

		alastErrorL = aerrorL;
		alastErrorR = aerrorR;

		acurrentL = aproportionL + aintegralL + aderivativeL;
		acurrentR = aproportionR + aintegralR + aderivativeR;

		motor[TR] = -acurrentR;
		motor[TL] = -acurrentL;

		wait1Msec(40);

	}
	return;

}

task main()
{



}
