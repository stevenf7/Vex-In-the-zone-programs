#pragma config(Sensor, in1,    MobilePotL,     sensorPotentiometer)
#pragma config(Sensor, in2,    MobilePotR,     sensorPotentiometer)
#pragma config(Sensor, in3,    ArmPotL,        sensorPotentiometer)
#pragma config(Sensor, in4,    ArmPotR,        sensorPotentiometer)
#pragma config(Sensor, in5,    ClawArmPotL,    sensorPotentiometer)
#pragma config(Sensor, in6,    ClawArmPotR,    sensorPotentiometer)
#pragma config(Sensor, dgtl1,  EncRoller,      sensorRotation)
#pragma config(Sensor, dgtl9,  EncRight,       sensorQuadEncoder)
#pragma config(Sensor, dgtl11, EncLeft,        sensorQuadEncoder)
#pragma config(Motor,  port1,           BR,            tmotorVex393_HBridge, openLoop, reversed, driveLeft, encoderPort, dgtl11)
#pragma config(Motor,  port2,           Left1,         tmotorVex393_MC29, openLoop, driveLeft, encoderPort, dgtl11)
#pragma config(Motor,  port3,           Roller,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           ClawArmL,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           TR,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           TL,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           ClawArmR,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           MobileGoalR,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           Right1,        tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, dgtl9)
#pragma config(Motor,  port10,          BL,            tmotorVex393_HBridge, openLoop, reversed, driveRight, encoderPort, dgtl9)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
int roptimalL=0;
void PID_Roller()
{
	float rkp = 0.16; //tune
	float rki = 0.00000001; //tune
	float rkd = 0.00000008; //tune

	float rcurrentL ;
	float rerrorTl;
	float rlastErrorL = 0;
	float rproportionL;
	float rintegralL;
	float rderivativeL;


	while(true){


		float rerrorL = roptimalL - SensorValue[Roller];

		if (abs(rerrorL) < 200 && rerrorL !=0)
		{
			rerrorTl = rerrorL;
		}
		else{
			rerrorTl = 0;
		}

		if (abs(rerrorTl)> 50 / rki){
		rerrorTl = 50 / rki;
		}

		if (rerrorL ==0){
			rderivativeL = 0;
		}

		rproportionL = rerrorL * rkp;
		rintegralL = rerrorTl  * rki;
		rderivativeL = (rerrorL - rlastErrorL) * rkd;
		rlastErrorL = rerrorL;
		rcurrentL = rproportionL + rintegralL + rderivativeL;

		motor[Roller] = -rcurrentL;
		wait1Msec(40);

	}
	return;

}

task main()
{
while (true){

if (vexRT[Btn7DXmtr2]){
motor[Roller] = 120;
SensorValue[EncRoller]=0;
}
else if (vexRT[Btn8DXmtr2]){
motor[Roller] = -120;
SensorValue[EncRoller]=0;
}
else {
PID_Roller();
}

wait1Msec(50);
}


}
